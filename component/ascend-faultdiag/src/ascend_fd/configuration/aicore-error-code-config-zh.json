{
    "(0, 0, 0)": "一般是aicore超时，或者手动构造了trap指令。",
    "(0x1, 0, 0)": "L2访问读越界，BIU_ERR_INFO中的biu_err_addr记录了越界的地址。",
    "(0x2, 0, 0)": "L2访问写越界，BIU_ERR_INFO中的biu_err_addr记录了越界的地址。",
    "(0x4, 0, 0)": "函数调用深度超过设置值。",
    "(0x8, 0, 0)": "scalar出现除0错误。",
    "(0x10, 0, 0)": "非法执行：\n1. 指令的binary错误\n2. 指令地址非对齐。",
    "(0x20, 0, 0)": "loop循环次数设置为0。",
    "(0x40, 0, 0)": "有程序jump，从其他地方跳到loop body中。",
    "(0x80, 0, 0)": "sqrt指令出现被开方数为负数。",
    "(0x100, 0, 0)": "ecc error，硬件问题。",
    "(0x200, 0, 0)": "cube指令的输入(L0A/L0B/L0C)数据含有NaN或者Inf，包含L0C累加场景。",
    "(0x400, 0, 0)": "ecc error，硬件问题。",
    "(0x800, 0, 0)": "L0A读写同地址冲突，比如L0AD 3D指令写L0A地址与MMAD指令读L0A地址相同，MTE_ERR_INFO中的mte_err_addr记录了冲突的地址。",
    "(0x1000, 0, 0)": "cube指令自动计算L0A地址时发生越界，X或者VA寄存器已经越界的情况不报此错误。",
    "(0x2000, 0, 0)": "ecc error，硬件问题。",
    "(0x4000, 0, 0)": "L0B读写同地址冲突，比如L0AD 3D指令写L0B地址与MMAD指令读L0B地址相同，CUBE_ERR_INFO中的cube_err_addr记录了冲突的地址。",
    "(0x8000, 0, 0)": "cube指令自动计算L0B地址时发生越界，X或者VA寄存器已经越界的情况不报此错误。",
    "(0x10000, 0, 0)": "ecc error，硬件问题。",
    "(0x20000, 0, 0)": "L0C读写同地址冲突，比如MMAD指令写L0C地址与MOV指令读L0C地址相同，CUBE_ERR_INFO中的cube_err_addr记录了冲突的地址。",
    "(0x40000, 0, 0)": "前后两条指令的L0C地址相同，可能同时出现对相同的L0C地址同时读写的场景，CUBE_ERR_INFO中的cube_err_addr记录了冲突的地址。",
    "(0x80000, 0, 0)": "cube指令自动计算L0C地址时发生越界，X或者VA寄存器已经越界的情况不报此错误。",
    "(0x100000, 0, 0)": "BIU返回bus error给IFU，意味着从out取指令错误，IFU_ERR_INFO中的ifu_err_type记录了异常类型，ifu_err_addr记录了错误的地址。",
    "(0x200000, 0, 0)": "AIPP指令aipp_spr寄存器配置有误，MTE_ERR_INFO中的mte_err_type记录了异常类型：\n3'b000: aipp_mte_ex_round：表示访问外部存储绕回\n3'b001: aipp_mte_l1_round：表示访问L1 buffer绕回\n3'b010: aipp_mte_inerr：表示配置AIPP SPR相关的fp16为INF或者NAN。",
    "(0x400000, 0, 0)": "L0AD 3D指令base read addr(Xn)越界。",
    "(0x800000, 0, 0)": "通过BIU读写out数据错误，MTE_ERR_INFO中的mte_err_type记录了异常类型，mte_err_addr记录了发生错误的地址(是触发问题的另一面的地址，比如out -> L1读错误，记的是L1地址，又如ub -> out写错误，记的是ub地址)。",
    "(0x1000000, 0, 0)": "L0AD 3D指令c0 index L1 overflow。",
    "(0x2000000, 0, 0)": "FMD指令异常，load index entry的数量和它后面最近的一个load decompressed data要解压的数据块数量不一致，MTE_ERR_INFO中的mte_err_type记录了异常类型：\n000 fmd_write_over_turn_err\n001 fmd_blk_num_zero_err\n010 fmd_blk_num_noequal_err\n011 fmd_header_err\n100 fmd_decompress_err",
    "(0x4000000, 0, 0)": "L0AD 3D指令1st filter window position大于Feature map size – Filter size。",
    "(0x8000000, 0, 0)": "L0AD 3D指令feature map size小于kernel size。",
    "(0x10000000, 0, 0)": "L0AD 3D指令w*h*c大于L1 size。",
    "(0x20000000, 0, 0)": "L0AD 3D指令fetch position in filter大于filter size。",
    "(0x40000000, 0, 0)": "DMA MOV指令burst_len不合法，不能为0。",
    "(0x80000000, 0, 0)": "DMA MOV指令burst_num不合法，不能为0。",
    "(0x100000000, 0, 0)": "DMA MOV指令读越界。",
    "(0x200000000, 0, 0)": "DMA MOV指令写越界。",
    "(0x400000000, 0, 0)": "FMC指令异常，当前index未处理完又下发新的index table,MTE_ERR_INFO中的mte_err_type记录了异常类型：000 fmc_read_over_turn_err和001 fmc_blk_num_zero_err。",
    "(0x800000000, 0, 0)": "L0AD 3D指令feature map size配置错误，有关的一些限制如下：\n1. Feature_map_size_w(after padding)>Filter_size_w(after dilation) Feature_map_size_h(after padding)>=Filter_size_h(after dilation).\n2. 1st filter window position <= Feature map size (with padding) – Filter size (after dilation).\n3. Stride size <= Feature map size (with padding) – Filter size (after dilation). This formula fit for the entire feature map in convolution. In terms of a single 3D Load instruction,the feature map may be partial. Then in w dimension, the formula is tenable; In H dimension,it should be ignored.\n4. Due to L1 Buffer size is 1MB, Feature map size (without padding) and C dimension index should meet: FeatureMapW * FeatureMapH * (CIndex +1) <= 32768 When repeat mode=0, the C index increment should be consider(Cincr denote the increment of C0 index during repeat):\nFeatureMapW * FeatureMapH * (CIndex +Cincr+1) <= 32768\nWhen set L1 3D size is valid, FeatureMapW * FeatureMapH * (CIndex +Cincr+1) <= L1_3D_size",
    "(0x1000000000, 0, 0)": "L0AD 3D指令L1_3D_SIZE配置错误，有关的一些限制如下：\nFeatureMapW * FeatureMapH * (CIndex +Cincr+1) <= L1_3D_size",
    "(0x2000000000, 0, 0)": "L0AD 3D指令stride配置错误，有关的一些限制如下：\n1. Stride size, W dimension ∈[1, 63](Bit width[5:0]), H dimension ∈[1, 63](Bit width[5:0])\n2. Stride size <= Feature map size (with padding) – Filter size (after dilation). This formula fit for the entire feature map in convolution. In terms of a single 3D Load instruction, the feature map may be partial. Then in w dimension, the formula is tenable; In H dimension, it should be ignored.",
    "(0x4000000000, 0, 0)": "L0A读写同地址冲突，比如L0AD 3D指令写L0A地址与MMAD指令读L0A地址相同，MTE_ERR_INFO中的mte_err_addr记录了冲突的地址。",
    "(0x8000000000, 0, 0)": "L0B读写同地址冲突，比如L0AD 3D指令写L0B地址与MMAD指令读L0B地址相同，CUBE_ERR_INFO中的cube_err_addr记录了冲突的地址。",
    "(0x10000000000, 0, 0)": "ecc error，硬件问题。",
    "(0x20000000000, 0, 0)": "LOAD 3D指令padding配置错误，和padding有关的一些限制如下：\n1. Feature_map_size_w(after padding)>Filter_size_w(after dilation)\n2. Feature_map_size_h(after padding)>=Filter_size_h(after dilation)\n3. 1st filter window position <= Feature map size (with padding) – Filter size (after dilation)\n4. Stride size <= Feature map size (with padding) – Filter size (after dilation).This formula fit for the entire feature map in convolution. In terms of a single 3D Load instruction, the feature map may be partial. Then in w dimension, the formula is tenable; In H dimension, it should be ignored.",
    "(0x40000000000, 0, 0)": "LOAD 2D读地址越界。",
    "(0x80000000000, 0, 0)": "ecc error，硬件问题。",
    "(0x100000000000, 0, 0)": "ecc error，硬件问题。",
    "(0x200000000000, 0, 0)": "ecc error，硬件问题。",
    "(0x400000000000, 0, 0)": "unzip指令异常，MTE_ERR_INFO中的mte_err_type记录了异常类型：\n000 uzp_write_over_turn_err\n001 uzp_blk_num_zero_err\n010 uzp_index_noenough_err\n011 uzp_index_err\n100 uzp_decompress_err",
    "(0x800000000000, 0, 0)": "LOAD 3D写地址越界。",
    "(0x1000000000000, 0, 0)": "LOAD 2D写地址越界。",
    "(0x2000000000000, 0, 0)": "scalar指令访问的UB地址，超过了DATA_EXP寄存器设置的UB访问地址范围。",
    "(0x4000000000000, 0, 0)": "mte指令访问的UB地址，超过了DATA_EXP寄存器设置的UB访问地址范围。",
    "(0x8000000000000, 0, 0)": "vector指令访问的UB地址，超过了DATA_EXP寄存器设置的UB访问地址范围。",
    "(0x10000000000000, 0, 0)": "VREC指令发生除0错误，VEC_ERR_INFO中的vec_err_rcnt记录了出错的repeat。",
    "(0x20000000000000, 0, 0)": "vector指令MASK域段为全0，VEC_ERR_INFO中的vec_err_rcnt记录了出错的repeat。",
    "(0x40000000000000, 0, 0)": "vector指令的操作数为Inf或者NaN，VEC_ERR_INFO中的vec_err_rcnt记录了出错的repeat。",
    "(0x80000000000000, 0, 0)": "ecc error，硬件问题。",
    "(0x100000000000000, 0, 0)": "L0C读写同地址冲突，比如MMAD指令写L0C地址与MOV指令读L0C地址相同,CUBE_ERR_INFO中的cube_err_addr记录了冲突的地址。",
    "(0x200000000000000, 0, 0)": "VLN指令的操作数为负数，VEC_ERR_INFO中的vec_err_rcnt记录了出错的repeat。",
    "(0x400000000000000, 0, 0)": "VSQRT指令被开方数为负数，VEC_ERR_INFO中的vec_err_rcnt记录了出错的repeat。",
    "(0x800000000000000, 0, 0)": "vector指令在同一个repeat写了相同的block，代码不会写出这样的指令，一般为硬件问题；VEC_ERR_INFO中的vec_err_rcnt记录了出错的repeat。",
    "(0x1000000000000000, 0, 0)": "ecc error，硬件问题。",
    "(0x2000000000000000, 0, 0)": "vector指令同时读写了UB的同一个地址，仅针对lite平台。",
    "(0x4000000000000000, 0, 0)": "vector指令自动计算UB地址时发生越界，X或者VA寄存器已经越界的情况不报此错误。",
    "(0x8000000000000000, 0, 0)": "BIU模块返回了一个综合型错误，把所有的错误类型或在一起。",
    "(0, 0x1, 0)": "在CCU的scalar buffer中报了ECC错误。",
    "(0, 0x2, 0)": "col2img的值非法。",
    "(0, 0x4, 0)": "col2img的值非法。",
    "(0, 0x8, 0)": "col2img的值非法。",
    "(0, 0x10, 0)": "col2img的值非法。",
    "(0, 0x20, 0)": "col2img的值非法。",
    "(0, 0x40, 0)": "col2img的值非法。",
    "(0, 0x80, 0)": "col2img的值非法。",
    "(0, 0x100, 0)": "CCU执行的浮点指令的输入为NaN/Inf。",
    "(0, 0x200, 0)": "small_channel使能标志有效，但不满足small_channel的条件。",
    "(0, 0x400, 0)": "MTE原子加地址未对齐(AIC、AIV1、AIV2)。",
    "(0, 0x800, 0)": "VEC指令访问的UB地址未对齐。",
    "(0, 0x1000, 0)": "VEC支持非法配置的指令。",
    "(0, 0x2000, 0)": "当前VEC版本不支持的指令。",
    "(0, 0x4000, 0)": "CCU指令地址检查错误。",
    "(0, 0x8000, 0)": "D-cache读写UB时, 总线返回的响应值为非零值。",
    "(0, 0x10000, 0)": "指令地址不对齐(ADDR_MISALIGN)。",
    "(0, 0x20000, 0)": "DEPTHWISE PADDING配置错误。",
    "(0, 0x40000, 0)": "DEPTHWISE FMAP上配置的H值小于3。",
    "(0, 0x80000, 0)": "WINOB向L0B地址写入时发生溢出。",
    "(0, 0x100000, 0)": "WINOB读取的L1地址溢出, 发生了循环。",
    "(0, 0x200000, 0)": "WINOA V padding的值非法。",
    "(0, 0x400000, 0)": "WINOA H padding的值非法。",
    "(0, 0x800000, 0)": "WINOA fmap W的值非法。",
    "(0, 0x1000000, 0)": "WINOA fmap H的值非法。",
    "(0, 0x2000000, 0)": "CHN_SIZE的值非法。",
    "(0, 0x4000000, 0)": "K_M_EXT_STEP的值非法。",
    "(0, 0x8000000, 0)": "K_M_START_POS的值非法。",
    "(0, 0x10000000, 0)": "MTE load3d指令的small K配置不正确。",
    "(0, 0x20000000, 0)": "MTE load3d指令的读取溢出。",
    "(0, 0x40000000, 0)": "VEC 问题队列中出现 2 位 ECC 错误。",
    "(0, 0x80000000, 0)": "数据缓存数据 RAM 中出现 2 位 ECC 错误。",
    "(0, 0x100000000, 0)": "数据缓存标签 RAM 中出现 2 位 ECC 错误。",
    "(0, 0x200000000, 0)": "FP32 DIV0 错误。",
    "(0, 0x400000000, 0)": "FP SQRT 计算单元的输入为负数。",
    "(0, 0x800000000, 0)": "在慢速上下文切换期间，SC 通过 AXI 总线传输数据，AXI 返回错误。",
    "(0, 0x1000000000, 0)": "读取 L0C、读取 L1 和写入 FIXP 缓冲区地址不对齐。",
    "(0, 0x2000000000, 0)": "FIXP 配置非法。",
    "(0, 0x4000000000, 0)": "L0C 的读取地址超出范围。",
    "(0, 0x8000000000, 0)": "L1 的读取地址超出范围。",
    "(0, 0x10000000000, 0)": "UB 的读取地址超出范围。",
    "(0, 0x20000000000, 0)": "L1 的写入地址超出范围。",
    "(0, 0x40000000000, 0)": "UB 的写入地址超出范围。",
    "(0, 0x80000000000, 0)": "FBUF 的写入地址超出范围。",
    "(0, 0x100000000000, 0)": "FBUF 的读取地址超出范围。",
    "(0, 0x200000000000, 0)": "安全检查期间nManager寄存器出现奇偶校验错误。",
    "(0, 0x400000000000, 0)": "从 MTE 内部 FIFO 读取的数据不正确。",
    "(0, 0x800000000000, 0)": "HWATI/HSET配置不正确。",
    "(0, 0x1000000000000, 0)": "安全功能期间 SU 内部缓冲区出现奇偶校验错误。",
    "(0, 0x2000000000000, 0)": "MTE内部MVF缓存故障。",
    "(0, 0x4000000000000, 0)": "CUBE HSET计数器下溢错误。",
    "(0, 0x8000000000000, 0)": "CUBE HSET计数器上溢错误。",
    "(0, 0x10000000000000, 0)": "MTE指令配置非法。",
    "(0, 0x20000000000000, 0)": "HEBCD指令配置非法。",
    "(0, 0x40000000000000, 0)": "HEBCE指令配置非法。",
    "(0, 0x80000000000000, 0)": "WAIPP指令配置非法。",
    "(0, 0x100000000000000, 0)": "SEQ命令序列不正确。",
    "(0, 0x200000000000000, 0)": "MPU地址访问无效。",
    "(0, 0x400000000000000, 0)": "缓冲区启用时，堆栈访问指令缓存缺失。",
    "(0, 0x800000000000000, 0)": "参数缓冲区出现2位ECC错误。",
    "(0, 0x1000000000000000, 0)": "MTE写入UB地址溢出。",
    "(0, 0x2000000000000000, 0)": "MTE读取UB地址溢出。",
    "(0, 0x4000000000000000, 0)": "CUBE指令配置非法。",
    "(0, 0x8000000000000000, 0)": "MTE CRC错误。",
    "(0, 0, 0x1)": "Lite Only错误，MTE读取UB时发生UB读/写冲突并报告异常。",
    "(0, 0, 0x2)": "Lite Only错误，MTE写入UB时发生UB读/写冲突。",
    "(0, 0, 0x4)": "MTE满时发生写地址冲突并报告异常。",
    "(0, 0, 0x8)": "MTE为空时发生读地址冲突并报告异常。",
    "(0, 0, 0x10)": "Lite Only错误，CCU读取UB时发生UB读/写冲突。",
    "(0, 0, 0x20)": "Lite Only错误，CCU向UB写入数据时发生UB读/写冲突。",
    "(0, 0, 0x40)": "AIC和AIV共享 UB 时发生LS/ST 问覆盖。",
    "(0, 0, 0x80)": "BIU上发生异常，例如tag_id错误或FIFO溢出。",
    "(0, 0, 0x100)": "MTE STB中发生多位ECC错误。",
    "(0, 0, 0x200)": "MTE AIPP中发生多位ECC错误。",
    "(0, 0, 0x400)": "标量LSU执行原子操作失败。",
    "(0, 0, 0x800)": "跨核心通信的标志计数器值超过最大值15。",
    "(0, 0, 0x1000)": "FIXP写入溢出错误。",
    "(0, 0, 0x2000)": "CUBE FIXP_BUFFER发生循环错误。",
    "(0, 0, 0x4000)": "FIXP指令错误：读取L0C时的ECC验证失败。",
    "(0, 0, 0x8000)": "FIXP读取L0C时发生读写操作冲突。",
    "(0, 0, 0x10000)": "mte读wino l0a溢出。",
    "(0, 0, 0x20000)": "mte写wino l0a溢出。",
    "(0, 0, 0x40000)": "MTE写入/读取时报告数据异常。",
    "(0, 0, 0x80000)": "SU写入/读取时报告数据异常。",
    "(0, 0, 0x100000)": "VECTOR写入/读取时报告数据异常。",
    "(0, 0, 0x200000)": "指令运行超时。",
    "(0, 0, 0x400000)": "指令在ISA中未定义。",
    "(0, 0, 0x800000)": "VEC指令配置非法。",
    "(0, 0, 0x1000000)": "指令访问UB地址未对齐。",
    "(0, 0, 0x2000000)": "掩码值无效。",
    "(0, 0, 0x4000000)": "sqzn值无效。",
    "(0, 0, 0x8000000)": "UB的访问地址超出范围。",
    "(0, 0, 0x10000000)": "访问UB时发生多位ECC错误。",
    "(0, 0, 0x20000000)": "指令操作的输入数据是INF/NAN。",
    "(0, 0, 0x40000000)": "VEC的除零错误。",
    "(0, 0, 0x80000000)": "VALU lN操作的输入数据是负数。",
    "(0, 0, 0x100000000)": "VALU squart操作的输入数据是负数。",
    "(0, 0, 0x200000000)": "VCI指令的输入数据超出范围。",
    "(0, 0, 0x400000000)": "VLOOP指令中的操作码错误。",
    "(0, 0, 0x800000000)": "第4层的VLOOP循环次数全部为0。",
    "(0, 0, 0x1000000000)": "ld指令所在的代码段包含非ld指令。",
    "(0, 0, 0x2000000000)": "st指令所在的代码段包含非st指令。",
    "(0, 0, 0x4000000000)": "ex指令所在的代码段包含非ex指令。",
    "(0, 0, 0x8000000000)": "ld指令数量超过ISA中指定的最大值。",
    "(0, 0, 0x10000000000)": "st指令数量超过ISA中指定的最大值。",
    "(0, 0, 0x20000000000)": "VAG和VPD的PADDING指令不是VNOP。",
    "(0, 0, 0x40000000000)": "VAG和VPD命令的顺序违反IAS约束。",
    "(0, 0, 0x80000000000)": "从VEC ICACHE中获取的指令发生ECC错误。",
    "(0, 0, 0x100000000000)": "BIU返回给VEC的数据错误。",
    "(0, 0, 0x200000000000)": "SU返回给VEC的PB数据包含ECC错误。",
    "(0, 0, 0x400000000000)": "SU从VEC接收PB读取请求后长时间不响应。",
    "(0, 0, 0x800000000000)": "VALU指令传输顺序违反ISA约束。"
}