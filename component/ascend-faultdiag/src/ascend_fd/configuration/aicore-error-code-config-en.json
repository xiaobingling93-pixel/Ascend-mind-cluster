{
    "(0, 0, 0)": "Generally, the cause is that the aicore times out or the trap command is manually constructed.",
    "(0x1, 0, 0)": "L2 access overwriting occurs. The biu_err_addr field in BIU_ERR_INFO records the out-of-bounds address.",
    "(0x2, 0, 0)": "L2 access write overwriting occurs. The biu_err_addr field in BIU_ERR_INFO records the out-of-bounds address.",
    "(0x4, 0, 0)": "The function invoking depth exceeds the configured value.",
    "(0x8, 0, 0)": "A division by 0 error occurred in scalar.",
    "(0x10, 0, 0)": "Illegal execution:\n1. The binary error of the instruction.\n2. The instruction address is not align.",
    "(0x20, 0, 0)": "The number of loop cycles is set to 0.",
    "(0x40, 0, 0)": "There is a program jump, where the flow jumps into the loop body from another location.",
    "(0x80, 0, 0)": "The sqrt instruction has a negative number under the square root.",
    "(0x100, 0, 0)": "ecc error, hardware fault.",
    "(0x200, 0, 0)": "The input (L0A/L0B/L0C) data of the cube instruction contains NaN or Inf, including the L0C accumulation scenario.",
    "(0x400, 0, 0)": "ecc error, hardware fault.",
    "(0x800, 0, 0)": "The L0A read/write operation conflicts with the same address. For example, the L0AD 3D instruction write address is the same as the MMAD instruction read L0A address, and mte_err_addr in MTE_ERR_INFO records the conflicting address.",
    "(0x1000, 0, 0)": "An out-of-bounds error occurs when the cube instruction automatically calculates the L0A address. This error is not reported if the X or VA register is already out of bounds.",
    "(0x2000, 0, 0)": "ECC error, hardware fault.",
    "(0x4000, 0, 0)": "The L0B read/write operation conflicts with the same address. For example, the L0AD 3D instruction write L0B address is the same as the MMAD instruction read L0B address. Cube_err_addr in CUBE_ERR_INFO records the conflicting address.",
    "(0x8000, 0, 0)": "An out-of-bounds error occurs when the cube instruction automatically calculates the L0B address. This error is not reported if the X or VA register is already out of bounds.",
    "(0x10000, 0, 0)": "ECC error, hardware fault.",
    "(0x20000, 0, 0)": "The L0C read and write operations conflict with the same address. For example, the MMAD instruction write L0C address is the same as the MOV instruction read L0C address. Cube_err_addr in CUBE_ERR_INFO records the conflicting address.",
    "(0x40000, 0, 0)": "The L0C addresses of the two preceding and following instructions are the same, which may result in simultaneous read and write operations on the same L0C address. The conflicting address is recorded in the cube_err_addr field of CUBE_ERR_INFO.",
    "(0x80000, 0, 0)": "An out-of-bounds error occurs when the cube instruction automatically calculates the L0C address. This error is not reported if the X or VA register is already out of bounds.",
    "(0x100000, 0, 0)": "BIU returns a bus error to IFU, indicating an error in fetching instructions from out. The ifu_err_type in IFU_ERR_INFO records the type of exception, and ifu_err_addr records the erroneous address.",
    "(0x200000, 0, 0)": "The AIPP instruction aipp_spr register is incorrectly configured. The mte_err_type field in MTE_ERR_INFO records the exception type.\n3'b000: aipp_mte_ex_round: indicates that the external storage is accessed.\n3'b001: aipp_mte_l1_round: indicates that the L1 buffer is accessed.\n3'b010: aipp_mte_inerr: indicates that the fp16 related to the AIPP SPR is set to INF or NAN.",
    "(0x400000, 0, 0)": "The L0AD 3D instruction is out of bounds, instruction: base read addr(Xn).",
    "(0x800000, 0, 0)": "When reading or writing out data through BIU results in an error, the `mte_err_type` in `MTE_ERR_INFO` records the type of exception, and `mte_err_addr` records the address where the error occurred (this is the address on the other side that triggered the issue, for example, if there is an L1 read error during an out operation, the L1 address is recorded; similarly, if there is a write error during a ub -> out operation, the ub address is recorded).",
    "(0x1000000, 0, 0)": "L0AD 3D instruction overflow, instruction: c0 index L1.",
    "(0x2000000, 0, 0)": "The FMD instruction is abnormal. The number of load index entries is different from the number of data blocks in the latest load decompressed data unzip. The mte_err_type field in MTE_ERR_INFO records the exception type.\n000 fmd_write_over_turn_err\n001 fmd_blk_num_zero_err\n010 fmd_blk_num_noequal_err\n011 fmd_header_err\n100 fmd_decompress_err",
    "(0x4000000, 0, 0)": "L0AD 3D instruction 1st filter window position is greater than (Feature map size – Filter size).",
    "(0x8000000, 0, 0)": "The feature map size of the L0AD 3D instruction is smaller than the kernel size.",
    "(0x10000000, 0, 0)": "L0AD 3D instruction w*h*c is greater than L1 size.",
    "(0x20000000, 0, 0)": "L0AD 3D instruction fetch position in filter is greater than filter size.",
    "(0x40000000, 0, 0)": "The burst_len of the DMA MOV instruction is invalid and cannot be 0.",
    "(0x80000000, 0, 0)": "The DMA MOV instruction burst_num is invalid and cannot be 0.",
    "(0x100000000, 0, 0)": "DMA MOV command read out of bounds.",
    "(0x200000000, 0, 0)": "DMA MOV instruction write out of bounds.",
    "(0x400000000, 0, 0)": "The FMC instruction is abnormal. A new index table is delivered before the current index is processed. The mte_err_type field in the MTE_ERR_INFO table records the exception types 000 fmc_read_over_turn_err and 001 fmc_blk_num_zero_err.",
    "(0x800000000, 0, 0)": "The feature map size of the L0AD 3D command is incorrectly configured. The restrictions are as follows:\n1. Feature_map_size_w(after padding)>Filter_size_w(after dilation) Feature_map_size_h(after padding)>=Filter_size_h(after dilation).\n2. 1st filter window position <= Feature map size (with padding) – Filter size (after dilation).\n3. Stride size <= Feature map size (with padding) – Filter size (after dilation). This formula fit for the entire feature map in convolution. In terms of a single 3D Load instruction,the feature map may be partial. Then in w dimension, the formula is tenable; In H dimension,it should be ignored.\n4. Due to L1 Buffer size is 1MB, Feature map size (without padding) and C dimension index should meet: FeatureMapW * FeatureMapH * (CIndex +1) <= 32768 When repeat mode=0, the C index increment should be consider(Cincr denote the increment of C0 index during repeat):\nFeatureMapW * FeatureMapH * (CIndex +Cincr+1) <= 32768\nWhen set L1 3D size is valid, FeatureMapW * FeatureMapH * (CIndex +Cincr+1) <= L1_3D_size",
    "(0x1000000000, 0, 0)": "The L0AD 3D instruction L1_3D_SIZE is incorrectly configured. The restrictions are as follows:\nFeatureMapW * FeatureMapH * (CIndex +Cincr+1) <= L1_3D_size",
    "(0x2000000000, 0, 0)": "The L0AD 3D instruction stride configuration is incorrect. The restrictions are as follows:\n1. Stride size, W dimension ∈[1, 63](Bit width[5:0]), H dimension ∈[1, 63](Bit width[5:0])\n2. Stride size <= Feature map size (with padding) – Filter size (after dilation). This formula fit for the entire feature map in convolution. In terms of a single 3D Load instruction, the feature map may be partial. Then in w dimension, the formula is tenable; In H dimension, it should be ignored.",
    "(0x4000000000, 0, 0)": "The L0A read/write operation conflicts with the same address. For example, the L0AD 3D instruction write address is the same as the MMAD instruction read L0A address, and mte_err_addr in MTE_ERR_INFO records the conflicting address.",
    "(0x8000000000, 0, 0)": "The L0B read/write operation conflicts with the same address. For example, the L0AD 3D instruction write L0B address is the same as the MMAD instruction read L0B address. Cube_err_addr in CUBE_ERR_INFO records the conflicting address.",
    "(0x10000000000, 0, 0)": "ECC error, hardware fault.",
    "(0x20000000000, 0, 0)": "The padding configuration of the LOAD 3D command is incorrect. The restrictions related to the padding are as follows:\n1. Feature_map_size_w(after padding)>Filter_size_w(after dilation)\n2. Feature_map_size_h(after padding)>=Filter_size_h(after dilation)\n3. 1st filter window position <= Feature map size (with padding) – Filter size (after dilation)\n4. Stride size <= Feature map size (with padding) – Filter size (after dilation).This formula fit for the entire feature map in convolution. In terms of a single 3D Load instruction, the feature map may be partial. Then in w dimension, the formula is tenable; In H dimension, it should be ignored.",
    "(0x40000000000, 0, 0)": "Load 2D read address out of range.",
    "(0x80000000000, 0, 0)": "ECC error, hardware fault.",
    "(0x100000000000, 0, 0)": "ECC error, hardware fault.",
    "(0x200000000000, 0, 0)": "ECC error, hardware fault.",
    "(0x400000000000, 0, 0)": "The unzip command is abnormal. The mte_err_type field in the MTE_ERR_INFO table records the exception type.\n000 uzp_write_over_turn_err\n001 uzp_blk_num_zero_err\n010 uzp_index_noenough_err\n011 uzp_index_err\n100 uzp_decompress_err",
    "(0x800000000000, 0, 0)": "LOAD 3D write address out of bounds.",
    "(0x1000000000000, 0, 0)": "LOAD 2D write address out of bounds.",
    "(0x2000000000000, 0, 0)": "The UB address accessed by the scalar instruction exceeds the UB access address range set by the DATA_EXP register.",
    "(0x4000000000000, 0, 0)": "The UB address accessed by the mte instruction exceeds the UB access address range set by the DATA_EXP register.",
    "(0x8000000000000, 0, 0)": "The UB address accessed by the vector instruction exceeds the UB access address range set by the DATA_EXP register.",
    "(0x10000000000000, 0, 0)": "A division by 0 error occurs in the VREC instruction. The vec_err_rcnt field in VEC_ERR_INFO records the repeated error.",
    "(0x20000000000000, 0, 0)": "The MASK field segment of the vector instruction is all zeros, and the vec_err_rcnt in VEC_ERR_INFO records the error.",
    "(0x40000000000000, 0, 0)": "The operand of the vector instruction is Inf or NaN. The vec_err_rcnt field in VEC_ERR_INFO records the incorrect repeat.",
    "(0x80000000000000, 0, 0)": "ECC error, hardware fault.",
    "(0x100000000000000, 0, 0)": "L0C read and write conflicts at the same address, for example, when the MMAD instruction writes to an L0C address that is the same as the address read by the MOV instruction. The cube_err_addr in CUBE_ERR_INFO records the conflicting address.",
    "(0x200000000000000, 0, 0)": "The operand of the VLN instruction is a negative number. The vec_err_rcnt field in VEC_ERR_INFO records the error repeat.",
    "(0x400000000000000, 0, 0)": "The VSQRT instruction encountered a negative number for square root calculation, and the vec_err_rcnt in VEC_ERR_INFO records the error.",
    "(0x800000000000000, 0, 0)": "The vector instruction writes the same block in the same repeat, but the code does not write such an instruction. Generally, the problem is caused by hardware. The vec_err_rcnt field in VEC_ERR_INFO records the repeated error information.",
    "(0x1000000000000000, 0, 0)": "ECC error, hardware fault.",
    "(0x2000000000000000, 0, 0)": "The vector command reads and writes the same address of the UB at the same time. This command applies only to the Lite platform.",
    "(0x4000000000000000, 0, 0)": "An out-of-bounds error occurs when the vector instruction automatically calculates the UB address. This error is not reported if the X or VA register is already out of bounds.",
    "(0x8000000000000000, 0, 0)": "The BIU module returned a composite error, which combined all the error types.",
    "(0, 0x1, 0)": "An ECC error is reported in the scalar buffer of the CCU.",
    "(0, 0x2, 0)": "The value of col2img is invalid.",
    "(0, 0x4, 0)": "The value of col2img is invalid.",
    "(0, 0x8, 0)": "The value of col2img is invalid.",
    "(0, 0x10, 0)": "The value of col2img is invalid.",
    "(0, 0x20, 0)": "The value of col2img is invalid.",
    "(0, 0x40, 0)": "The value of col2img is invalid.",
    "(0, 0x80, 0)": "The value of col2img is invalid.",
    "(0, 0x100, 0)": "The input for floating-point instructions executed by the CCU is NaN/Inf.",
    "(0, 0x200, 0)": "The small_channel enable flag is valid, but the conditions for small_channel are not met.",
    "(0, 0x400, 0)": "The MTE atomic address is not align (AIC, AIV1, AIV2).",
    "(0, 0x800, 0)": "The UB address accessed by the VEC command is not align.",
    "(0, 0x1000, 0)": "The VEC supports an invalid command.",
    "(0, 0x2000, 0)": "The command is not supported by the current VEC version.",
    "(0, 0x4000, 0)": "The CCU command address check is incorrect.",
    "(0, 0x8000, 0)": "When the D-cache reads or writes data to the UB, the response value returned by the bus is a non-zero value.",
    "(0, 0x10000, 0)": "The instruction address is not align (ADDR_MISALIGN).",
    "(0, 0x20000, 0)": "DEPTHWISE PADDING configuration error.",
    "(0, 0x40000, 0)": "The H value configured on the DEPTHWISE FMAP is less than 3.",
    "(0, 0x80000, 0)": "An overflow occurred when WINOB wrote to the L0B address.",
    "(0, 0x100000, 0)": "The L1 address read by WINOB overflowed and a loop occurred.",
    "(0, 0x200000, 0)": "The value of WINOA V padding is invalid.",
    "(0, 0x400000, 0)": "The value of WINOA H padding is invalid.",
    "(0, 0x800000, 0)": "The value of WINOA fmap W is invalid.",
    "(0, 0x1000000, 0)": "The value of WINOA fmap H is invalid.",
    "(0, 0x2000000, 0)": "The value of CHN_SIZE is invalid.",
    "(0, 0x4000000, 0)": "The value of K_M_EXT_STEP is invalid.",
    "(0, 0x8000000, 0)": "The value of K_M_START_POS is invalid.",
    "(0, 0x10000000, 0)": "The small K configuration of the MTE load3d instruction is incorrect.",
    "(0, 0x20000000, 0)": "Overflow in the reading of the MTE LOAD 3D instruction.",
    "(0, 0x40000000, 0)": "A 2-bit ECC error occurred in the VEC problem queue.",
    "(0, 0x80000000, 0)": "A 2-bit ECC error occurs in the data cache data RAM.",
    "(0, 0x100000000, 0)": "A 2-bit ECC error occurs in the data cache tag RAM.",
    "(0, 0x200000000, 0)": "FP32 DIV0 error.",
    "(0, 0x400000000, 0)": "The input of FP SQRT compute unit is a negative number.",
    "(0, 0x800000000, 0)": "During the slow context switchover, the SC transfers data through the AXI bus, and the AXI returns an error.",
    "(0, 0x1000000000, 0)": "Reading L0C, reading L1, and writing to the FIXP buffer address is not align.",
    "(0, 0x2000000000, 0)": "The FixP configuration is invalid.",
    "(0, 0x4000000000, 0)": "The L0C read address is out of range.",
    "(0, 0x8000000000, 0)": "The read address for L1 is out of range.",
    "(0, 0x10000000000, 0)": "The read address for UB is out of range.",
    "(0, 0x20000000000, 0)": "The write address for L1 is out of range.",
    "(0, 0x40000000000, 0)": "The UB write address is out of range.",
    "(0, 0x80000000000, 0)": "The FBUF write address is out of range.",
    "(0, 0x100000000000, 0)": "The FBUF read address is out of range.",
    "(0, 0x200000000000, 0)": "Parity error in the nManager register during security check.",
    "(0, 0x400000000000, 0)": "The data read from the internal FIFO of the MTE is incorrect.",
    "(0, 0x800000000000, 0)": "HWATI/HSET configuration error.",
    "(0, 0x1000000000000, 0)": "A parity error occurred in the SU internal buffer during the security function.",
    "(0, 0x2000000000000, 0)": "The MTE internal MVF cache is faulty.",
    "(0, 0x4000000000000, 0)": "CUBE HSET counter underflow error.",
    "(0, 0x8000000000000, 0)": "CUBE HSET counter overflow error.",
    "(0, 0x10000000000000, 0)": "Invalid MTE instruction configuration.",
    "(0, 0x20000000000000, 0)": "The HEBCD command configuration is invalid.",
    "(0, 0x40000000000000, 0)": "The HEBCE command configuration is invalid.",
    "(0, 0x80000000000000, 0)": "The WAIPP command configuration is invalid.",
    "(0, 0x100000000000000, 0)": "The SEQ command sequence is incorrect.",
    "(0, 0x200000000000000, 0)": "The MPU address access is invalid.",
    "(0, 0x400000000000000, 0)": "Stack access instruction cache is missing when buffer is enabled.",
    "(0, 0x800000000000000, 0)": "A 2-bit ECC error occurs in the parameter buffer.",
    "(0, 0x1000000000000000, 0)": "The MTE writes the UB address overflow.",
    "(0, 0x2000000000000000, 0)": "The MTE reads the UB address overflow.",
    "(0, 0x4000000000000000, 0)": "Invalid configuration of the Cube command.",
    "(0, 0x8000000000000000, 0)": "MTE CRC error.",
    "(0, 0, 0x1)": "Lite Only error. When the MTE reads the UB, a UB read/write conflict occurs and an exception is reported.",
    "(0, 0, 0x2)": "Lite Only error. A UB read/write conflict occurs when the MTE writes data to the UB.",
    "(0, 0, 0x4)": "A write address conflict occurs and an exception is reported when the MTE is full.",
    "(0, 0, 0x8)": "A read address conflict occurs and an exception is reported when MTE is empty.",
    "(0, 0, 0x10)": "A Lite Only error occurs. When the CCU reads the UB, a UB read/write conflict occurs.",
    "(0, 0, 0x20)": "A Lite Only error occurs. When the CCU writes data to the UB, a UB read/write conflict occurs.",
    "(0, 0, 0x40)": "LS/ST overwrite occurs when AIC and AIV share UB.",
    "(0, 0, 0x80)": "An exception occurred on the BIU, such as a tag_id error or FIFO overflow.",
    "(0, 0, 0x100)": "A multi-bit ECC error occurs in the MTE STB.",
    "(0, 0, 0x200)": "A multi-bit ECC error occurred in the MTE AIPP.",
    "(0, 0, 0x400)": "The scalar LSU failed to perform the atomic operation.",
    "(0, 0, 0x800)": "Flag counter value for cross-core communication exceeds the maximum value of 15.",
    "(0, 0, 0x1000)": "The FIXP writes to the buffer overflow error.",
    "(0, 0, 0x2000)": "A cyclic error occurred on CUBE FIXP_BUFFER.",
    "(0, 0, 0x4000)": "FIXP instruction error: ECC validation failed while reading L0C.",
    "(0, 0, 0x8000)": "A read/write conflict occurs when the FIXP reads the L0C.",
    "(0, 0, 0x10000)": "Overflow occurs when the MTE reads wino l0a.",
    "(0, 0, 0x20000)": "MTE write wino l0a overflow.",
    "(0, 0, 0x40000)": "MTE reports a data exception when writing/reading.",
    "(0, 0, 0x80000)": "SU reports a data exception when writing/reading.",
    "(0, 0, 0x100000)": "VECTOR reports data anomalies during write/read operations.",
    "(0, 0, 0x200000)": "Command run timed out.",
    "(0, 0, 0x400000)": "The instruction is not defined in ISA.",
    "(0, 0, 0x800000)": "The VEC command configuration is invalid.",
    "(0, 0, 0x1000000)": "The instruction accesses the UB address without align.",
    "(0, 0, 0x2000000)": "Invalid mask value.",
    "(0, 0, 0x4000000)": "Invalid sqzn value.",
    "(0, 0, 0x8000000)": "The access address of the UB is out of range.",
    "(0, 0, 0x10000000)": "A multi-bit ECC error occurred while accessing the UB.",
    "(0, 0, 0x20000000)": "The input data for the instruction operation is INF/NAN.",
    "(0, 0, 0x40000000)": "Divide by zero error for VEC.",
    "(0, 0, 0x80000000)": "The input data for the VALU lN operation is negative.",
    "(0, 0, 0x100000000)": "The input data for the VALU squart operation is negative.",
    "(0, 0, 0x200000000)": "The input data for the VCI instruction is out of range.",
    "(0, 0, 0x400000000)": "Wrong opcode in VLOOP instruction.",
    "(0, 0, 0x800000000)": "The number of VLOOP cycles at Layer 4 is all zeros.",
    "(0, 0, 0x1000000000)": "The code segment containing the ld instruction includes non-ld instructions.",
    "(0, 0, 0x2000000000)": "The code segment containing the st instruction includes non-st instructions.",
    "(0, 0, 0x4000000000)": "The code segment containing the ex instruction includes non-ex instructions.",
    "(0, 0, 0x8000000000)": "The number of ld instructions exceeds the maximum specified in ISA.",
    "(0, 0, 0x10000000000)": "The number of st instructions exceeds the maximum specified in ISA.",
    "(0, 0, 0x20000000000)": "The PADDING instruction of VAG and VPD is not VNOP.",
    "(0, 0, 0x40000000000)": "The order of the VAG and VPD commands violates the IAS constraint.",
    "(0, 0, 0x80000000000)": "An ECC error occurred on the instruction fetched from the VEC ICACHE.",
    "(0, 0, 0x100000000000)": "The data returned by the BIU to the VEC is incorrect.",
    "(0, 0, 0x200000000000)": "The PB data returned by the SU to the VEC contains ECC errors.",
    "(0, 0, 0x400000000000)": "The SU does not respond for a long time after receiving the PB read request from the VEC.",
    "(0, 0, 0x800000000000)": "The VALU instruction transfer sequence violates the ISA constraint."
}